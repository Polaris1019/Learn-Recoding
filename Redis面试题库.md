## Redis

### 认识 Redis

#### 1、什么是 Redis？

**回答：**
Redis 是一个开源的内存数据结构存储系统，支持多种数据结构（如字符串、哈希、列表、集合等），常用于缓存、分布式锁。它通过将数据存储在内存中实现高速读写，并支持持久化到磁盘，确保数据安全。Redis 还提供主从复制、事务和 Lua 脚本等功能，适用于高并发场景。

#### 2、使用 Redis 有哪些好处？

**分析：**
使用 Redis 有以下几个显著好处：

1. 高性能：数据存储在内存中，读写速度极快，适合高并发场景。
2. 丰富的数据结构：支持字符串、哈希、列表、集合、有序集合等多种数据结构，满足多样化需求。
3. 持久化：支持 RDB 和 AOF 两种持久化方式，确保数据安全。
4. 高可用性：通过主从复制和哨兵模式实现故障转移，保障服务连续性。
5. 分布式：支持集群模式，可水平扩展，处理大规模数据。
6. 多功能：提供事务、发布订阅、Lua 脚本等功能，增强灵活性。
7. 广泛应用：适用于缓存、会话存储、消息队列、实时排行榜等场景。

这些优势使 Redis 成为高性能数据存储和缓存的理想选择，回答时候选几个点来说就行，高性能和持久化一定要提到。

**回答：**

具有以下好处：

- 读取速度快，因为数据存在内存中，所以数据获取快
- 支持多种数据类型，包括字符串、列表、集合、有序集合、哈希等
- 还拥有其他丰富的功能，队列、主从复制、集群、数据持久化等功能。

#### 3、为什么 MySQL 做存储，Redis 做缓存？

**分析：**

使用 Redis 作为 MySQL 的缓存有以下几个主要原因：

1. 提升性能：Redis 将数据存储在内存中，读写速度远快于基于磁盘的 MySQL，显著减少数据库查询延迟。
2. 减轻数据库负载：通过缓存频繁访问的数据，减少对 MySQL 的直接查询，降低数据库压力，提高系统整体性能。
3. 高并发支持：Redis 能处理大量并发请求，适合高流量场景，避免 MySQL 成为瓶颈。
4. 灵活数据结构：Redis 支持多种数据结构（如字符串、哈希、列表等），便于缓存复杂查询结果或中间数据。
5. 缓存失效策略：Redis 支持设置缓存过期时间，确保数据及时更新，避免脏数据
6. 高可用性：Redis 提供主从复制和持久化功能，确保缓存数据的高可用性和可靠性。

综上，Redis 作为 MySQL 缓存能显著提升系统性能、降低数据库负载，并支持高并发场景。

**回答：**

MySQL 是数据库系统，对于数据的操作需要访问磁盘，而将数据放故在 Redis 中，需要访问就可以直接从内存获取，避免磁盘I/O，提高操作的速度，使 Redis+MySQL 结合的方式可可以有效提高系统 QPS。

#### 4、Redis 常用的业务场景有哪些？

**分析：**

主要常用的业务场景有：

- 对热点数据的缓存：因为 Redis 支持多种数据类型，数据存储在内存中，访问速度块，所以 Redis 很适合用来存储热点数据
- 限时类业务的实现：可以使用 expire 命令设置 key 的生存时间，到时间后自动删除key。例如使用在验证码验证、优惠活动等业务场景
- 计数器的实现：因为 incrby 命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成。例如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等业务场景。
- 排行榜的实现：借助 Sorted Set 进行热点数据的排序。例如：下单量最多的用户排行榜，最热门的帖子（回复最多）等业务场景
- 分布式锁实现：可以利用 Redis 的 setnx 命令进行。
- 队列机制实现：Redis 提供了 list push 和 list pop 这样的命命令，所以能够很方便的执行队列操作。

**回答：**

Redis 常用业务场景包括缓存、计数器、分布式锁、排行榜等，其中缓存和分布式锁是最核心和广泛的应用场景。

### Redis 数据对象

#### 5、Redis 的数据类型有哪些？

**回答：**

Redis 提供了丰富的数据类型，常见的有五种数据类型：String（字符串），Hash（哈希），List（列表），Set（集合），Zset（有序集合）。

Redis 五种数据类型的应用场景：

- String 类型的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等。
- List 类型的应用场景：消息队列（但是有两个问题：1、生产者需要自行实现全局唯一ID；2、不能以消费组形式消费数据）等。
- Hash 类型：缓存对象、购物车等。
- Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。
- Zset 类型：排序场景，比如排行榜、电话和姓名排序等。

#### 6、Redis 有哪些底层数据结构？

**分析：**

数据对象通常指 String、List、Set、Hash、ZSet 这些，它们是用户直接能操作的数据类型，而他们具体实现还依托于底层数据结构，包括 SDS、链表、压缩列表等，回答时候可以列举，如果特别熟悉某一种可以专门提出来，引导面试官追问。

**回答（这里是往跳表引导，根据自身掌握情况选择引导方向）：**

数据对象 String、List、Set、Hash、ZSet 的实现都依托于底层数据结构，这些结构包括 SDS、链表、压缩列表、哈希表、跳表等，比如 ZSet 就是利用跳表高效实现了有序集合的能力。

### String

#### 7、Set 一个已有的数据会发生什么？

**回答：**
Set 一个已有数据会覆盖原有的值，同时会覆盖或者擦除键的过期时间。

#### 8、浮点型在 String 是用什么表示？

**回答：**
要将一个浮点数放入字符串对象里面，需要先将这个浮点数转换成字符串值，然后再保存转换所得的字符串值。浮点数在字符串对象里面是用字符串值表示的，用 Raw 还是 Emnbstr 编码，取决于转换后字符串的长度。

#### 9、String 可以有多大？

**回答：**
一个 Redis 字符串最大为512MB，官网有明确注明，我看源码里也是直接写死的

#### 10、Redis 字符串是怎么实现的？

**分析：**
这个问题，首先需要分情况说出编码类型，分别应用在什么场景。

EMBSTR 编码和 RAW 编码的选择阈值也比较重要，回答的时候，可以先说自己用的Redis 版本的数值，面试官会感觉你确实有关注过编码的阈值。

如果能记得是3.2版本之前是39，3.2版本之后才是44，也可以说出来，有一定程度的加分，但是说了这个差别可能会引导面试官追问为什么，如果记不清就不要说版本差别了。

**回答：**
Redis 字符串底层是 String 对象，String 对象有三种编码方式：INNT型、EMBSTR型、RAW型。如果是存一个整型，可以用 long 表示的整数就以 INT 编码存储；如果存字符串，当字符串长度小于等于一个阈值，使用 EMBSTR 编码；字符串大于阈值，则用 RAW 编码。在我用的5.0.5版本中阈值是44。

#### 11、为什么 EMBSTR 的阈值是44？（几乎不考）

**回答：**

Redis 是使用 jemalloc 内存分配器，jemalloc 以64字节为阈值区分大小字符串。

所以 EMBSTR 的边界数值，其实是受64这个阈值影响。

redisObject 占用的内存大小由 redisObject 和 sdshdr 这两部分组成，redisObject 16字节，sdshdr 中已分配、已申请、标记三个字段固定占了3个字节，'\0'占了一个字节，能存放的数据就是64-(16+4)=44。

#### 12、你知道为什么 EMBSTR 曾经的阈值是39吗？（几乎不考）

**回答：**

3.2之后的版本，SDS 结构进行了拆分，EMBSTR 用的 sdshdr8，总容量和已使用容量字段减少了6个字节，但由于增加了一个 flags 字段，所以最终节约了5个字节。

#### 13、SDS 有什么用？

**回答：**

主要有三点：

1. SDS 包含已使用容量字段，O(1)时间快速返回有字符串长度，相比之下，C原生字符串需要O(n)。
2. 有预留空间，在扩容时如果预留空间足够，就不用再重新分配内存，节约性能，缩容时也可以将减少的空间先保留下来，后续可以再使用。
3. 不再以 \0' 作为判断标准，二进制安全，可以很方便地存储一些二进制数据。

### List

#### 14、List 是完全先入先出吗？

**回答：**
List 是双端操作对象，所以不是完全的先入先出，List 也可以后入先出。

#### 15、List 对象底层编码方式是什么？

**回答：**
在3.2版本之前，List 对象的编码是 ZIPLIST 和 LINKEDLIST。ZIPLIST 适用于元素数量较少、且元素都较短的情况，否则用 LINKEDLIST。

3.2版本之后，List 对象的编码全部由 QUICKLIST 实现。QUICKLIST 是一个压缩列表组成的双向链表，结合了 ZIPLIST 和 LINKEDLIST 两者的优点，在后面比较新的版本（Redis7.0）中 ZIPLIST 优化为了 LISTPACK。

#### 16、ZIPLIST 是怎么压缩数据的？

**回答：**
压缩列表是一块连续的内存空间，元素之间是紧挨着存储的，一个压缩列表中可以包含多个节点（entry），是在连续的内存空间上实现的双端链表，对于一个普通的双向链表，链表中每一项都占用独立的一块内花存，各项之间用地址指针（或引用）连接起来。这种方式会带来大量的内存碎片，而且地址指针也会占用额外的内花存。而 ZIPLIST 却是将表中每一项存放在前后连续的地址空间内，一个 ZIPLIST 整体占用一大块内存。而且 ZIPLIST entry 对于不同类型会有不同长度的数据存储，保证还可能的压缩内存。

#### 17、ZIPLIST 下 List 可以从后往前遍历吗？

**回答：**
可以，List 是双端数据结构，无论哪种底层编码，都需要能支持/从后往前遍历。ZIPLIST 每个节点中都保存了上一个节点的长度，所以可以用当前节点地址减去上一个节点长度来找到上个节点起始位置，进而实现从后往前的遍历。

#### 18、在 ZIPLIST 数据结构下，查询节点个数的时间复杂度是多少？

**回答：**
在 ZIPLIST 编码下，查询节点个数的时间复杂度是O(1)，因为 ZIPLIST 中的 header 定义了记录节点数量的字段，但是这里也有个限制，记录节点数量的字段只有2字节，也就说如果节点数量超过65535，就失效了，此时只能通过O(n)复杂度的遍历来查节点总数。

#### 19、LINKEDLIST 编码下，查询节点个数的时间复杂度是多少？

**回答：**
LINKEDLIST 编码下，查询节点个数的时间复杂度是O(1)。因为 LINKEDLIST 的表头结构中定义了链表所包含节点数量的字段 len。

### Set

#### 20、Set 编码方式？

**回答：**
Set 使用整数集合和字典作为底层编码，当元素都是整数同时元素个数不超过512个，会使用整数集合编码，否则使用字典编码。

#### 21、Set 是有序的吗？

**回答：**
Set 的底层实现是整数集合或字典，前者是有序的，后者是无序的。整体来看，但是不应该依赖 SET 的顺序，业务使用适合始终应该按无序来用。

#### 22、Set 为什么要用两种编码方式？

**回答：**
Set 的底层编码是整数集合和字典，当元素数量小并且全部是是整数的时候，会使用整数集合编码，更加的节约内存。元素数量变大会使用字典编码，查找元素的速度会更快。

### Hash

#### 23、Hash 的编码方式是什么？

**分析：**
Hash 底层有两种编码结构，一个是 ZIPLIST，一个是 HashTable。ZIPLIST 适用于元素较少且单个元素长度较小的情况，这里的阈值分别是元素个数少于512个，值和键长度都小于64字节。

**回答：**
一个是 ZIPLIST，一个是 HashTable。ZIPLIST 适用于元素较少目单个元素长度较小的情况，其它情况使用 HashTable。

#### 24、Hash 查找某个 key 的平均时间复杂度是多少？

**回答：**
Hash 有两种底层结构，ZIPLIST 时是O(n)，HashTable 则是O(1)。

#### 25、Redis 中 HashTable 查找元素总数的平均时间复杂度是多少？

**回答：**
HashTable 查找元素总数的平均时间复杂度是O(1)，因为 HashTable 的表头结构中有储存键值对数量的字段，这个字段我记得叫 used。

#### 26、一个数据在 HashTable 中的存储位置，是怎么计算的？

**回答：**
首先会通过哈希函数计算出 key 的哈希值，然后与哈希掩码做与运算得到索引值，索引值就是这个数据在 HashTable 中的存储位置。

#### 27、HashTable 怎么扩容？

**回答：**
首先程序会为 HashTable 的1号表分配空间，空间大小是第一个大于等于0号表大小*2的2^n。在 rehash 进行期间，标记位 rehashidx 从0开始，每次对字典的键值对执行增删改查操作后，都会将 rehashidx 位置的数据迁移到1号表，然后将 rehashidx 加1，随着字典操作的不断执行，最终0号表的所有键值对都会被 rehash 到1号表上。之后，1号表会被设置成0号表，接着在1号表的位置创建一个新的空白表。

#### 28、HashTable 怎么缩容？

**回答：**
首先程序会为 HashTable 的1号表分配空间，新表大小为第一个大于等于原表 used 的2次方幂。在 rehash 进行期间，标记位 rehashidx 从0开始，每次对字典的键值对执行增删改查操作后，都会将 rehashidx 位置的数据迁移到1号表，然后将 rehashidx 加1，随着字典操作的不断执行，最终0号表的所有键值对都会被 rehash 到1号表上。之后，1号表会被设置成0号表，接着在1号表的位置创建一个新的空白表。

#### 29、HashTable 什么时候扩容，什么时候缩容

**回答：**
我先说扩容，当以下两个条件中的任意一个被满足时，哈希表会自动开始扩容：
第一个是服务器目前没有在执行 BGSAVE 或者 BGREWRITEAOF，并且负载因子>=1
第二个是服务器目前正在执行 BGSAVE 或者 BGREWRITEAOF，并且负载因子>=5
缩容的话也是负载因子影响，当哈希表的负载因子小于0.1时，程序会自动开始对哈希表进行收缩操作。

### ZSet

#### 30、ZSet 底层有几种编码方式？

**回答：**
ZSet 就是有序集合对象，ZSet 对象的底层有两种编码方式：ziplist 或者 skiplist+字典。

如果一个 ZSet 对象中的所有元素同时满足：元素数量小于128个以及所有元素成员的长度都小于64字节，那么会使用 ziplist 编码，否则使用 skiplist+字典编码。

#### 31、跳表编码模式下，查询节点总数的平均时间复杂度是多少？

**回答：**
跳表编码模式下，查询节点总数的平均时间复杂度是O(1)，因为跳表的表头结构中定义了一个保存节点数量的字段 length，源码中调用查询节点总数的 API 时会直接返回这个字段。

#### 32、跳表插入一条数据的平均时间复杂度是多少

**回答：**
跳跃表是一种支持多级索引的结构，查询效率可以媲美二分查找，插入一条数据也是需要先查找，找到之后会进行索引的重建，整体平均时间复杂度是O(logN)。

#### 33、为什么跳表和 HashTable 要配合使用

**回答：**
为了结合这两种数据结构各自的优势，当 ZSet 要根据成员来查找分值的时候，将使用字典来实现，时间复杂度为O(1)。而当 ZSet 要执行范围操作时，比如 ZRANK、ZRANGE 等命令时，将使用原本就有序的跳跃表来实现。

#### 34、跳表中一个节点的层高是怎么决定的？

**回答：**
跳表在插入新节点之前会计算一个随机的层高，具体来说，跳表的每一个节点一开始默认都是1层，然后每增加一层的概率都是25%，最高为32层。

#### 35、ZSet 为什么用跳表而不用平衡树？

**回答：**

- 跳表的实现非常灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。
- 跳表的代码实现比平衡树来说，实现要简单多了，平衡树插入和删除都会导致树的旋转，实现起来很复杂，而跳表就简单很多，跳表插入就比普通的链表插入节点稍复杂一点。
- 按照区间来查找数据这个操作（比如查找值在[100，200]之间的数据），平衡树的效率没有跳表高。对于按照区间查找数据这个操作，跳表可以做到O(logn)的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了，这样做非常高效。

总体来说，主要是为了代码的简单、易读、不容易出错，比起平衡树复杂性，Redis 选择用了跳表。

### Redis执行

#### 36、Redis 是单线程还是多线程

#### 37、Redis 为什么选择单线程做核心处理

#### 38、Redis 单线程性能如何？

#### 39、为什么单线程还能这么快

#### 40、Redis6.0 之后引入了多线程，你知道为什么吗？

#### 41、Redis6.0 的多线程是默认开启的吗？

#### 42、Redis6.0 的多线程主要负责命令执行的哪一块

### Redis持久化

#### 43、RDB 和 AOF 本质区别是什么？

#### 44、如果 RDB 和 AOF 只能选一种，你选哪个？

#### 45、介绍一下 AOF 的三种写回策略？

#### 46、为什么先执行 Redis 命令，再把数据写入 AOF 日志呢？

#### 47、AOF 子进程的内存数据跟主进程的内存数据不一致怎么办？

#### 48、RDB 在执行快照的时候，数据能修改吗？

#### 49、Redis 用 RDB 持久化时对过期键会如何处理的？

#### 50、Redis 用 AOF 持久化时对过期键会如何处理的？

#### 51、AOF 模式下，Redis 主从模式中，对过期键会如何处理？

#### 52、RDB 持久化的触发时机？（简单了解）

#### 53、AOF 刷盘的触发时机（几乎不考）

#### 54、RDB 对主流程有什么影响？（几乎不考）

#### 55、AOF 对主流程有什么影响？（几乎不考）

#### 56、AOF 混合持久化方案是什么？

#### 57、简单描述 AOF 重写流程

#### 58、AOF 重写你觉得有什么不足之处么？

#### 59、针对 AOF 重写的不足，你有什么优化思路呢？

### Redis过期删除策略和内存淘汰策略

#### 60、Redis 是怎么删除过期 key 的？

#### 61、Redis 有几种内存回收策略？

#### 62、内存回收是什么时候发起

#### 63、介绍下 Redis LRU 回收算法

#### 64、Redis LRU 算法是标准的吗？为什么不用标准的

#### 65、什么是 LFU 算法，为什么 Redis 要引入 LFU 算法

### Redis场景

66、你有实际使用过Redis做什么应用么？
67、Redis缓存是如何应用的？
68、Redis经常作为MySQL的缓存来使用，为什么？
69、Redis和Memcached有哪些共同点和不同点
70、Redis做旁路缓存，如果MySQL更新了，此时何去何从？
71、如何保证删除缓存操作一定能成功？
72、业务缓存一致性要求高怎么办？
73、如何避免缓存失效？
74、Redis做秒杀场景可以吗？讲讲思路

75、Redis管道有什么用？
76、Redis如何处理大key？
77、Redis支持事务回滚吗？
78、Redis如何实现延迟队列？

### Redis分布式锁

79、Redis可以做消息队列吗？什么时候能用Redis做消息队列？
80、什么是分布式锁？
81、如何理解Redis原子性操作原理？
82、分布式锁实现要点是什么（其实就是怎么加锁、怎么解锁、怎么用）？
83、为什么需要引入owner的概念呢？
84、你提到了lua，用lua一定能保证原子性？
85、基于Redis实现分布式锁有什么优缺点？
86、使用Redis实现分布式锁的优点？
87、使用Redis实现分布式锁的缺点？
88、如何为Redis分布式锁设置合理的超时时间？
89、除了Redis实现分布式锁，还有哪些方案可以实现分布式锁？各有什么优缺点？
90、怎么用Redis实现可重入的分布式锁？

91、对Redisson分布式锁了解多少？（Java）
92、Redisson是怎么实现锁自动续期的？（Java）
93、Redis Redisson看门狗续期，是用一个后台线程去续期的，如果发生了GC停顿，导致这个线程无法执行，导致锁没有续期，这时候怎么办（Java）
94、Redis如何解决集群情况下分布式锁的可靠性？

### Redis缓存异常

95、缓存穿透是什么？怎么解决？
96、布隆过滤器是怎么工作的？
97、布隆过滤器有什么缺陷？
98、缓存击穿是什么？怎么解决？
99、缓存雪崩是什么？怎么解决？

### Redis集群

100、Redis集群架构模式有哪几种？
101、Redis主从复制过程是怎样的？
102、Redis的主从复制模式有什么优缺点？
103、哨兵机制是什么？
104、哨兵机制的工作原理？
105、Redissentinel（哨兵）模式优缺点有哪些？
106、说说Redis哈希槽的概念？
107、哈希槽和Redis节点是如何对应的？
108、主从模式的同步过程？
109、从服务重新上线之后，主服务器如何知道要将哪些增量数据发送给从服务器？
110、Redis如何减少主从数据的不一致？
111、主从模式是同步复制还是异步复制？