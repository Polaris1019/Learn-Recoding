## MySQL

###  SQL语法

#### 1、count 主键和 count 非主键结果会不同吗？

##### 分析：

count() 函数是返回表中某个列的非 NULL 值的数量。

- 由于主键的列不能存 NULL 值，所以 count(主键) 返回的结果，可以表示数据库表中所有行数据的数量。
- 由于非主键的列可以存 NULL 值，那么 count(非主键) 返回表中非主键列的非 NULL 值的数量。

##### 回答：

主键是不能存 NULL 值的，所以 count 主键代表统计表中所有行数据的数量。

而非主键是可以存 NULL 值的，所以 count 非主键统计的是表中这这个列的非 NULL 值的数量。

#### 2、MySQL 内连接、外连接有什么区别？

##### 回答：

内连接和外连接都是用于连表查询。

内连接是只返回两个表匹配的数据行，外连接可以返回两个表匹配和不匹配的数据行，外连接主要分为左连接和右连接。

- 左连接返回左表中的所有行和右表中匹配的行，如果右表中没有匹配的行，则用 NULL 值填充。
- 右连接返回右表中的所有行和左表中匹配的行，如果左表中没有匹配的行，则用NULL值填充。

#### 3、外连接时 on 和 where 过滤条件区别？

##### 分析：

- 对于内连接（inner join）查询，WHERE 和 ON 中的过滤条件等效；
- 对于外连接（outer join）查询，ON 中的过滤条件在连接时进行，WHERE 中的过滤条件在连接操作之后执行。

##### 回答：

在外连接中，使用 on 和 where 过滤条件的区别在于：

- on 用于指定连接两个表的条件，通常用于指定两个表之间的关联条件，即连接条件，在连接时进行过滤。
- where 用于指定过滤条件，对连接后的结果集进行进一步筛选。

#### 4、having 与 where 的区别？

##### 分析：

WHERE 与 HAVING 的根本区别在于：

- WHERE 子句在 GROUPBY 分组和聚合函数之前对数据行进行过滤，where 子句无法使用聚合函数。
- HAVING 子句对 GROUPBY 分组和聚合函数之后的数据行进行过滤，having 子句可以使用聚合函数。

##### 回答：

在 GROUP BY 分组查询过程中，Where 是工作在 GROUP BY 之前，Where 是对分组之前的数据进行筛选，无法使用聚合函数，Having 是工作在 GROUP BY 之后，Having 主要更对分组之后的数据进行筛选，可以使用聚合函数。

#### 5、EXISTS 和 IN 的区别是什么？

##### 回答：

**内部工作原理区别：**

- in 是先执行内表，会把查询到内表数据缓存起来，然后会进行双重 for 循环，外层的 for 循环是遍历外表记录，内层的 for 循环是遍历内表记录，最后每一次 for 循环时在内为存判断内表的记录与外表记录是否一致。
- exist 会for循环遍历外表的记录,每一次for循环都会进行一次内查询来判断数据是否匹配。

**性能区别：**

- 如果查询的两个表大小相当，那么用 in 和 exists 性能差别不大。
- 如果查询的两个表中一个是小表，一个是大表，IN 适合于外表大而内表小的情况，EXISTS适合于外表小而内表大的情况。

#### 6、MySQL 的约束有哪些？

##### 回答：

数据库的约束主要有6大约束，分别是主键约束、外键约束、唯一性约束、非空约束、默认约束、检查约束。

MySQL只支持前5钟约束，不支持检查约束。

MySQL支持的这些约束的作用如下：

- 主键约束的作用唯一标识一条记录，不能重复也不能为空，一张长表数据库表只能有一个主键，一般我们会针对 id 字段设置为主键。
- 外键约束的作用是确保表与表之间引用的完整性。
- 唯一性约束的作用是保证字段在表中的数值是唯一的，如果插入人相同字段值的记录，就会报唯一性约束的错误。
- 非空约束的作用是保证字段不能为 NULL。
- 默认约束的作用是给字段设置默认值，如果插入数据的时候，这个字段没有取值的话，就会用默认值。

#### 7、delete、drop、truncate 有什么区别？

##### 回答：

delete 是删除表中的数据，我们可以选择删除部分数据或者全部都数据，delete 删除的数据是可以回滚的；delete 操作并不是真的把数据删除掉了，而是给数据打上删除标记，目的的是为了空间复用，所以 delete 删除表数据，磁盘文件的大小是不会缩减的。
drop 是删除表结构和表中所有的数据，truncate 是只删除表中所有的记录，表结构并不会被删除，drop 和 truncate 删除的数据都是不可以回滚的，并且删除表会立刻料放磁盘空间。
从删除表的性能来看，drop > truncate > delete。

#### 8、联合查询中 union 和 unionall 的区别是什么？

##### 回答：

UNION：在合并结果集后会自动剔除重复的行。
UNION ALL：则会保留所有的重复行，不会进行去重操作。

#### 9、数据库三大范式是什么？追问1：范式设计是为了解决什么问题？追问2：范式设计有什么缺点？

##### 回答：

- 一范式要求所有属性都是不可分的基本数据项；
- 二范式目的是解决部分依赖；
- 三范式目的是解决传递依赖。

在实际的工程实践上没有必要严格遵循三范式要求，比如说可以通过字段冗余的设计，避免联表查询。

##### 追问1回答：

数据库的范式是为了解决**数据冗余、数据不一致性、数据更新异常和插入异常**等问题。

- **数据冗余：**数据冗余是指数据库中存储了大量重复的数据，这不仅良费了存储空间，而且可能导致数据不一致的问题。范式通过规定数据的结构和组织方式，使得每一份数据只需要被存储一次，从而避免了数据冗余。

- **数据更新异常：**更新异常是指当我们尝试更新一份数据时，可能需要在多个地方进行修改，而如果某一处修改被遗漏，就会导致数据不一致的问题。范式通过规定数据的的组织和关联方式，使得每一份数据只需要被修改一次，从而避免了更新异常。

- **插入异常：**插入异常是指当我们尝试插入一份新的数据时，可能因为数据的组织和关联方式的问题，而无法进行插入。范式通过规定数据的组织和关联方式，使得任何合法的新数据都可以被顺利插入，从而避免了插入异常。

- **保证数据的一致性和完整性：**范式化的设计通过消除数据冗余和依赖关系,使得数据的一致性和完整性得到保证。当数据只存在于一个位置时，更新和修改数据更加简单和可靠。通过实施数据库范式，开发人员能够确保数据库架构更具可维护性和可扩展性，尤其在处理大型数据居集时，范式化能够确保数据的一致性，并使数据库操作更高效。

  ##### 追问2回答：

  范式化将数据分解为多个表，那么查询数据的时候，就需要要进行更多的表连接操作，在应用中，进行表关联的成本是很高，也不适合分库分表的场景，所以有时候实际应用，设计表的的时候会反范式的，比如说可以通过字段冗余的设计，避免联表查询。

#### 10、count(*) 性能比 count(1) 好吗？

##### 回答：

不是的。

MySQL 会将星号参数转化为参数 0 来处理，所以 count(*) 和 count(1) 性能是一样的。

### 存储引擎

#### 11、说一说执行一条查询 SQL 语句的全过程

##### 回答：

MySQL 执行一条查询 SQL 语句的时候，会经过连接器、查询缓存、解析器、优化器、执行器、存储引擎这些模块。

- 首先 MySQL 的连接器会负责建立连接、校验用户身份、接收客户端的 SQL 语句；
- 第二步 MySQL 会在查询缓存中查找数据，如果命中直接返回数据线合客户端，否则就需要继续往下查询，不过查询缓存功能在 MySQL8.0 版本被删除了，原因是只要对这张表进行了写操作，这张表的查询缓存就会失效，所以在实际场景中，查询缓存的命中率其实不高；
- 第三步 MySQL 的解析器会对 SQL 语句进行词法分析和语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；
- 第四步 MySQL 的优化器会基于查询成本的考虑，会判断每个索引的执行成本，从中选择查询成本最小的执行计划；
- 第五步 MySQL 的执行器会根据执行计划来执行查询语句，从存储引擎读取记录，返回给客户端。

#### 12、MySQL 存储引擎有哪些？

##### 回答：

MySQL 常见的存储引擎有 **InnoDB、MyISAM、Memory**。

- 我比较熟悉的是 InnoDB 引擎，它是 MySQL 默认的存储引擎，支持事务和行级锁，具有事务提交、回滚和崩溃恢复功能。
- MyISAM 引擎我没有用过，但是我在学习的时候有了解过，它是不不支持事务和行级锁的，而且由于只支持表锁，锁的粒度比较大，更新性能比较差，我认为它比较适合读多写少的场景。
- Memory 引擎我了解不多，大概知道它是将数据存储在内存中，所以数据的读写还是比较快的，但是数据不具备持久性，我觉得适用于临时存储数据的场景。

#### 13、MyISAM 和 InnoDB 存储引擎有什么区别？

##### 回答：

InnoDB 引擎和 MyISAM 引擎在数据存储上有很大区别，InnoDB引擎数据存储的方式采用的是索引组织表，在索引组织表中，数据即索引，索引即数据，因此表数据和索引数据都存储在同一个文件中。MyISAM引擎数据存储的方式采用的是堆表，在堆表的组织结构中，数据和索引分开存储，因此表数据和索引数据会分别放在两个不同的文件中存储，索引组织表有两个优势：

- 在索引组织表将索引和数据保存在同一个 B+ 树中，相比非聚簇亲引每次查询都需要回表，因此从聚簇索引中获取数据比非聚簇索引更快，查询数据会更快
- 在索引组织表中，如果记录发生了修改，则其他索引无须进行维护，除非记录的主键发生了修改，而当堆表的数据发生改变目位置发生了变更，那么所有索引中的地址都要更新，这非常影响性能。

另外，InnoDB 引擎支持行级锁和事务，而 MyISAM 引擎都不支持，只支持表锁。

#### 14、MySQL 为什么选择 InnoDB 作为默认引擎？

##### 回答：

InnoDB 引擎在事务支持、并发性能、崩溃恢复等方面具有优势，因此被 MySQL 选择为默认的存储引擎。

- 事务支持：InnoDB 引擎提供了对事务的支持，可以进行 ACID （原子性、一致性、隔离性、持久性）属性的操作。MyISAM存储引擎是不支持事务的。
- 并发性能：InnoDB 引擎采用了行级锁定的机制，可以提供更好的发性能，MyISAM 存储引擎只支持表锁，锁的粒度比较大。
- 崩溃恢复：InnoD 引擎通过 redolog 日志实现了崩溃恢复可以在数据库发生异常情况（如断电）时，通过日志文件进行恢复，保证数据的持久性和一致性。MyISAM 是不支持崩溃恢复的。

#### 15、用 count(*) 哪个存储引擎会更快？

##### 回答：

如果查询语句没有 where 查询条件的话，用 MyISAM 引擎会比较快，因为MyISAM 引擎的每张表会用一个变量存储表的总记录个数，执行 count 函数的时候，直接读这个变量就行了，而 InnoDB 引擎执行 count 函数的时候，需要通过遍历的方式来统计记录个数。

如果查询语句有 where 查询条件的话，MyISAM 和 InnoDB 引擎执行 count 函数的时候，性能都差不多，都需要根据查询条件一行行的进行统计。

#### 16、NULL 值是如何存储的？

##### 回答：

MySQL 行格式中会用「NULL值列表」来标记值为 NULL 的列，每个列对应一个二进制位，如果列的值为 NULL，就会标记二进制位为1，否则为0，所以 NULL 值并不会存储在行格式中的真实数据部分。

NULL 值列表最少会占用1字节空间，当表中所有列都定义成 NOT NULL，行格式中就不会有 NULL 值列表，这样可以至少节省1字节的空间。

#### 17、char 和 varchar 有什么区别？追问:哪个性能更好？

##### 回答：

- char 是固定长度的字符串类型，它在数据库中占用固定的存储空间，无论实际存储的数据长度是多少，都会占用定义时指定的固定长度，如果实际存储的字符串长度小于定义的长度，系统会自动用空格填充。比如如果定义一个 char(10) 类型的字段，即使实际数据只使用5字节，会自动地填充5字节的空格，使得存储空间固定占用10字节。
- Varchar 是可变长度的字符串类型。实际存储时只占用实际字符串长度的空间，不会进行空格填充。比如如果定义一个 varchar(10) 类型的字段，并存储了一个长度为5的字符串，那么它只会占用5个字节的存储空间，并且还会额外用1-2字节存储「可变长字符串长度」的空间。

##### 追问回答：

站在 CPU 角度来看，理论上 CHAR 比 VARCHAR 更快，因为 CHAR 是固定长度的，而 VARCHAR 需要增加一个长度标识，处理时需要多一次运算。

但性能是综合各种因素后的最终结果，当 InnoDB buffer pool 小于表大小时，“磁盘读写”成为了性能的关键因素，而 VARCHAR 更短，因此性能反而比 CHAR 高。但是当 InnoDB buffer pool 足够大时，CHAR 和 VARCHAR 性能没有太大的差别了。

#### 18、假如说一个字段是 varchar(10)，但它其实只有6个字节，那他在内存中古的存储空间是多少？在文件中占的存储空间是多少？

##### 回答：

内存会占用10字节，文件存储空间会占用6字节，并且还会额外用1-2字节存储「可变长字符串长度」的空间。

#### 19、如果硬件内存特别大，MySQL 缓存能否替代 redis？

##### 分析：

这个是一个字节的面试题，这里的 MySQL 缓存代表用于缓存数据页的 buffer pool，所以问题的意思是，假设 buffer pool 无限大，能在内存装下所有数据，是否可以替代 redis？问题的回答思路，要去想 redis 缓存哪些优点是 MySQL 没有的？

##### 回答：

我觉得还是不能替代。

- MySQL 所有模块，比如 buffer pool、日志技术、事务并发模快，都是面向磁盘页而设计的，因此其首要目标不是减少内存访问的代价，而是减少 I/0 的代价，所以内存访问代价却并不是最优的选择，而Redis是面向内存而设计的数据库。
- MySQL 在内存查询一个数据页的时候，都需要先查页表，也就是需要走 B+ 树的搜索过程，时间复杂度是 O(logdN)，而 Redis 提供了很多种的数据类型，比如用 Hash 数据对象的时候，可以在 O(1) 时间复杂度查到数据。
- MySQL 在更新数据的时候，MySQL 为了保证事务的隔离性，是需要加锁的，而 Redis 更新操作都是不需要加锁的，还有 MySQL 为了保证事务的持久性，还需要刷盘 redolog 日志和 binlog 日志，Redis 可以选择不持久化数据。

因此，即使 buffer pool 无限大，MySQL缓存的性能还是没有 Redis 好的。

### 索引结构（重要）

#### 20、MySQL 有哪些索引类型？

##### 分析：

B+ 树索引、哈希索引、全文索引的区别:

- B+ 树索引：B+ 树索引是一种平衡树数据结构，它将数据按照索引键值有序地存储在树的叶子节点上，非叶子节点只存储索引键值和指向下一层节点的指针，适合于范围查找、排序查询、等值查询的情况，并且性能稳定；因为B+ 树保存千万级别的数据，树的高度依然维持在3~4层左右，也就是从千万级数据查询一条数据只需要3~4次的磁盘 I/O 操作就能查询到目标数据。
- 哈希索引：哈希索引是通过哈希算法将键值（key-value）映射到哈希表中,再根据哈希表进行索引操作。哈希索引适合于等值查询，例如根据主键查询某条记录，查询时间复杂杂度为 O(1)，效率非常高，但不支持排序、范围查询及模糊查询等。
- 全文索引：全文索引是一种用于全文搜索的索引技术，可以对文本内容进行索引，支持关键词的模糊匹配和搜索。一般用于查找文本中的关键字，而不是直接比较是否相等，主要是用来解决 WHERE name LIKE "%aaaa%" 等针对文本的模糊查询效率低的问题。

##### 回答：

我了解到 MySQL 支持 B+ 树索引、哈希索引、全文索引这三种素引类型。我比较常用的是 B+ 树索引，因为它是 InnodB 引擎默认使用的索引类型，支持排序、分组、范围查询、模糊查询等功能。

#### 21、InnodB 引擎的索引数据结构是什么？

##### 回答：

我了解到 InnodB 引擎是采用了 B+ 树作为索引的数据结构。它的一些特性:

1. 数据组织形式：InnodB 存储引擎的主键索引 B+ 树的非叶子节点只存放索引键值和指向子节点的指针，不存储实际的数据，这里对应到 MySQL 中就是索引，叶子节点存储素引健值和行数据，所以 InnodB 存储引擎的主键索引属于聚簇索引。
2. 叶子节点链表：所有叶子节点通过指针相连，形成一个双向链表，支持快速的顺序访问和范围查询。
3. 平衡树结构：所有叶子节点在同一层上，树的高度平衡，保证任何数据记录的查找、插入、删除和更新操作的路径长度相同，稳定性好。

#### 22、B+ 树的特性是什么？

##### 回答：

![image-20250326223752295](C:\Users\MXD\AppData\Roaming\Typora\typora-user-images\image-20250326223752295.png)

B+ 树是一个多叉树，一个父节点，可以有多个子节点，主要的特性有三个:

- B+ 树的中间节点不会存储数据，而只有叶子节点才会存储，中间节点只用于存储到叶子节点的路由信息（即索引），而且每个节点里的数据都是根据素引的值来顺序存放的。
- B+ 树的所有的叶子节点之间会通过双向指针串联在一起，构成一个双向链表，可以方便扫表和范围查询。
- B+ 查询性能稳定，因为所有叶子节点都在同一层，确保了所有数据项的检索都具有相同的 I/O 延迟，而且 B+ 树保存千万级别的数据，树的高度依然维持在3~4层左右，也就是从千万级数据查询一条数据只需要3~4次的磁盘 I/O 操作就能查询到目标数据。

#### 23、B+ 和 B 树有什么区别？

##### 回答：

B+ 和 B 树都是多叉平衡树，每个节点包含多个键和多条链，主要的区别有这些：

- B 树所有节点都会存储索引+数据，而B+树只有叶子节点才会存储数据，中间节点则只有索引，因此存储相同数据量的情况下，B+ 树可以比B树更矮胖，查询叶子节点的磁盘 I/O 次数会更少。
- B+ 树叶子节点之间会通过双向指针串联在一起，构成一个双向链表，这种设计对范围查找非常有帮助，而 B 树没有将所有叶子节点用链表串联起来的结构，只能通过中序遍历来完成范围查询，这会比 B+ 树范围查询涉及更多个节点的磁盘 I/O 操作，因此范围查询效率不如 B+ 树。
- B 树的优势是当你要查找的值恰好处在一个非叶子节点时，由于干该节点也包含数据，查找到该节点就会成功并结束查询，最快可以在 O(1) 的时间代价内就查到，而 B+ 树由于数据只在叶子节点，所以每次查询都需要从根节点搜索到叶子节点，从平均时间代价来看，会比 B+ 树稍快一些，但是 B+ 树的查询会更稳定，因为每次查询都是相同的 I/O 延迟。

#### 24、MySQL 为什么使用 B+ 树？

##### 回答：

- B+ 树是多叉树，而平衡二叉树、红黑树是二叉树，在同等数据量下，平衡二叉树、红黑树高度更高，磁盘IO次数更多，性能更差，而且它们会频繁执行再平衡过程，来保证树形结构平衡。
- 跳表和 B+ 树相比，跳表在极端情况下会退化为链表，平衡性差，而数据库查询需要一个可预期的查询时间，并且跳表需要更多的内存。
- B 树和 B+ 树相比，B树的数据存储在全部节点中，对范围查询不友好。非叶子节点存储了数据，导致内存中难以放下全部非叶子节点。如果内存放不下非叶子节点，那么就意味着查询非叶子节点的时候都需要磁盘IO。

#### 25、为什么索引用 B+ 树？而不用红黑树？

##### 回答：

我觉得主要原因是随着数据量的增多，红黑树的树高会比 B+ 树的树高，这样查询数据的时候会面临更多的磁盘 I/O，查询性能没那么好。因为红黑树本质上是二叉树，而B+权对是多叉树，存储相同数量量的情况下，红黑树的树高会比 B+ 树的树高，由于 InnodB 引擎的数据都是存储在磁盘上的，如果树的高度越高，意味着磁盘 I/O 就越多，这样就会影响查询性能。
另外，B+ 树叶子节点是通过双向链表组织的，可以很好的实现范围查询，红黑树要实现范围查询需要通过中序遍历，这会比 B+ 树范围查询涉及更多个节点的磁盘 I/O 操作，因此范围查询效率不如 B+ 树。
所以，B+ 树相比红黑树有两个优势，第一个优势是 B+ 树随着数据的增多的时候树的高度会比红黑树低，第二优势是 B+ 树范围查询很方便，直接通过叶子节点的链表就能完完成了，因此 InnodB 存储引擎选择了 B+ 树作为索引。

#### 26、为什么索引用 B+ 树？而不用 B 树？

##### 回答：

我觉得主要有三个原因：

- **B+ 树的磁盘读写代价更低：**B+ 树只有叶子节点才会存放索引和数据，非节点只存放索引，而 B 树所有节点都会存放索引和数据，因此存储相同数据量的情况下，B+ 树可以比 B 树更矮胖，查询叶子节点的磁盘 I/O 次数会更少
- **B+ 树便于范围查询：**MySQL 是需要经常使用范围查询的，B+ 树所有叶子节点间会用链表进行连接，这种设计对范围查找非常有帮助，而 B 树没有将所有叶子节点用链表串联起来的结构，只能通过中序遍历来完成范围查询，这会比 B+ 树范围查询涉及更多个节点的磁盘 I/O 操作，因此范围查询效率不如 B+ 树
- **B+ 树增删查改效率更加稳定：**B+ 树有大量的冗余节点，这些冗余数据可以让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树对的变化。另外，B+ 树把所有的用户记录都放到了叶子节点这一层,因此查询、插入、删除数据都需要走到最后一层，这不同于B树可能在任意一层找到数据，所以 B+ 树更为稳定。

所以，InnoDB 引擎的索引选择了 B+ 树。

#### 27、为什么索引用 B+ 树？而不用哈希表？

##### 分析;

1. 哈希表的数据是散列分布的，不具备有序性，无法进行范围查和排序
2. 哈希表存在哈希冲突的问题，哈希冲突严重，也会降低查询效率

##### 回答:

MySQL 会有很多范围查询和排序的场景，虽然哈希表的搜索时间复杂度是 O(1)，但是由于哈希表的数据都是通过哈希函数计算后散列分布的，所以哈希表索引不支持范围查询和排序操作，不支持联合索引最左匹配原则，如果重复键值比较多，还容易造成哈希碰撞导致效率进一步降低。而 B+ 树可以满足这些应用场景，因此选择了用 B+ 树索引。

#### 28、B+ 树有什么优点和缺点？

##### 回答：

**B+ 树有一个最大的好处是方便范围查询**，B+ 树的叶子节点之间有链表，直接通过叶子节点链表就能方便的完成范围查询的工作，而 B 树必须用中序遍历的方法来实现范围查询间，这会比 B+ 树范围查询涉及更多个节点的磁盘 I/O 操作，因此范围查询效率不如 B+ 树。
**B+树最大的性能问题是会产生大量的随机IO**，随着新数据的插入，叶子节点会慢慢分裂，逻辑上连续的叶子节点在物理上往往不连续,甚至分离的很远，但做范围查询时，会产生大量读随机 IO 。对于大量的随机写也一样，举一个插入 key 跨度很大的例子，如 7->1000->3->2000.... 新插入的数据存储在磁盘上相隔很远，会产生大量的随机写 IO。

#### 29、聚簇索引和非聚簇索引有什么区别？

##### 回答：

聚簇索引和非聚簇索引（二级索引）最主要的区别是 B+ 树叶子书点存放的内容不同：

- 聚簇索引的 B+ 树叶子节点存放的是主键值+完整的记录
- 非聚簇索引的 B+ 树叶子节点存放的是索引值+主键值

如果查询语句的查询条件用了二级索引，但是查询的数据不是主键值，也不是二级索引值，这时在二级索引找到主键值后，就需要回表才能查找到数据，需要扫描两次 B+ 树。如果查询的列是主键值和二级索引值时，因为只在二级索引就能查询到，这时候就会用到覆盖索引，不需要回表，只需要扫描一次 B+ 树。

#### 30、什么是覆盖索引？

##### 回答：

当查询的数据是能在二级索引的叶子节点里查询到的话，这l时就不用再回主键索引查了，那就不需要回到主键索引去查行记录了，这种不需要回表的过程，就叫覆盖索引，这种查询方式效率会比较高，只需要查二级索引这一棵 B+ 树。

#### 31、什么情况下会回表？

##### 回答：

在使用二级索引进行查询的时候，如果查询的列，不能在二级索引中全部查询到，那么就会发生回表的过程，先通过二级索引的值查到聚簇索引值（即主键id），再通过聚簇索引的的值定位行记录数据，需要扫描两次索引 B+ 树，它的性能较扫一遍索引树更低。

#### 32、insert 操作对 B+ 树结构的改变是怎么样的？

##### 回答：

B+ 树的数据都是有序的，所以：

- 如果我们使用主键是顺序递增，那么每次插入的新数据就会顺序插入到叶子节点最右边的节点里，如果该页面满了，就会自动开辟一个新页面，将新数据插入到新页面。因为每次插入一条新记录，都是追加操作，不需要重新移动数据，因此这种插入数据的方法效率非常高。
- 如果我们使用主键不是顺序递增，由于每次插入主键的索引值都是是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这时候为了保证 B+ 树的有序性，要移动其它数据来满足新数据的插入。如果该页面满了，就发生页分裂，这时候要从一个页面复制数据到到另外一个页面，目的是保证后一个数据页中的所有行主键值比前一个数据页中主键值大，页分裂可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。

所以，我们在设计主键的时候，最好采用自增的方式，或者顺序递增主键值。

#### 33、假如一张表有两千万的数据，B+ 树的高度是多少？怎么算的？



2025年3月27日

------



### 索引应用（重要）

34、MySQL 有哪些索引？

35、MySQL 主键是聚簇索引吗？

36、主键为什么不推荐有业务含义？

37、主键是用自增还是 UUID  ？

38、普通索引和唯一索引有什么区别？哪个更新性能更好？

39、主键怎么设置？

​	追问：假如你不设置会怎么样？

40、介绍一下什么是外键约束？

41、外键有什么优劣势？

42、为什么要建索引？

43、我们一般选择什么样的字段来建立索引？

44、索引越多越好吗？

45、什么时候不用索引更好？

46、字段为什么要定义为NOT NULL？

47、索引怎么优化？

48、建立了索引，查询的时候一定会用到索引吗？

49、如果我定义了一个 varchar 类型的日期字段，并且有一个数据是 ‘202330922’，如果这个日期字段上有索引，那如果我查询的 where 条件是where time=20230922 不加单引号，还会命中索引吗？为什么？

50、MySQL 最新版本解决了索引失效的哪些情况了吗？

51、什么是最左匹配原则？

52、建立联合索引有什么需要注意的？

53、了解索引下推吗？什么情况下会下推到引擎去处理？

54、联合索引(a,b,c)，下面的查询语句会不会走索引？如果走具体是哪些字段能走？

55、where a>1 and b=2 and c<3 怎么建立索引？
56、where a=？and b=？order by c 怎么建立索引？

57、where a>100 and b=100 and c=123 order by d 怎么建立联合索引？
58、select b from table where a=10 and c>20 怎么创建索引？

59、select id, name from XX where age > 10 and name like 'xx%'，有联合索引 (name,age)，说一下查询过程

60、where id NOT IN (?,?,?) 会走索引吗？
61、如果查询条件中包含索引列和非索引列，MySQL 的具体查询流程是什么样的？