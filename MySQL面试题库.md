## MySQL

###  SQL语法

#### 1、count 主键和 count 非主键结果会不同吗？

##### 分析：

count() 函数是返回表中某个列的非 NULL 值的数量。

- 由于主键的列不能存 NULL 值，所以 count(主键) 返回的结果，可以表示数据库表中所有行数据的数量。
- 由于非主键的列可以存 NULL 值，那么 count(非主键) 返回表中非主键列的非 NULL 值的数量。

##### 回答：

主键是不能存 NULL 值的，所以 count 主键代表统计表中所有行数据的数量。

而非主键是可以存 NULL 值的，所以 count 非主键统计的是表中这这个列的非 NULL 值的数量。

#### 2、MySQL 内连接、外连接有什么区别？

##### 回答：

内连接和外连接都是用于连表查询。

内连接是只返回两个表匹配的数据行，外连接可以返回两个表匹配和不匹配的数据行，外连接主要分为左连接和右连接。

- 左连接返回左表中的所有行和右表中匹配的行，如果右表中没有匹配的行，则用 NULL 值填充。
- 右连接返回右表中的所有行和左表中匹配的行，如果左表中没有匹配的行，则用NULL值填充。

#### 3、外连接时 on 和 where 过滤条件区别？

##### 分析：

- 对于内连接（inner join）查询，WHERE 和 ON 中的过滤条件等效；
- 对于外连接（outer join）查询，ON 中的过滤条件在连接时进行，WHERE 中的过滤条件在连接操作之后执行。

##### 回答：

在外连接中，使用 on 和 where 过滤条件的区别在于：

- on 用于指定连接两个表的条件，通常用于指定两个表之间的关联条件，即连接条件，在连接时进行过滤。
- where 用于指定过滤条件，对连接后的结果集进行进一步筛选。

#### 4、having 与 where 的区别？

##### 分析：

WHERE 与 HAVING 的根本区别在于：

- WHERE 子句在 GROUP BY 分组和聚合函数之前对数据行进行过滤，where 子句无法使用聚合函数。
- HAVING 子句对 GROUP BY 分组和聚合函数之后的数据行进行过滤，having 子句可以使用聚合函数。

##### 回答：

在 GROUP BY 分组查询过程中，Where 是工作在 GROUP BY 之前，Where 是对分组之前的数据进行筛选，无法使用聚合函数，Having 是工作在 GROUP BY 之后，Having 主要对分组之后的数据进行筛选，可以使用聚合函数。

#### 5、EXISTS 和 IN 的区别是什么？

##### 回答：

**内部工作原理区别：**

- in 是先执行内表，会把查询到内表数据缓存起来，然后会进行双重 for 循环，外层的 for 循环是遍历外表记录，内层的 for 循环是遍历内表记录，最后每一次 for 循环时在内存判断内表的记录与外表记录是否一致。
- exist 会 for 循环遍历外表的记录，每一次 for 循环都会进行一次内查询来判断数据是否匹配。

**性能区别：**

- 如果查询的两个表大小相当，那么用 in 和 exists 性能差别不大。
- 如果查询的两个表中一个是小表，一个是大表，IN 适合于外表大而内表小的情况，EXISTS适合于外表小而内表大的情况。

#### 6、MySQL 的约束有哪些？

##### 回答：

数据库的约束主要有6大约束，分别是主键约束、外键约束、唯一性约束、非空约束、默认约束、检查约束。

MySQL只支持前5钟约束，不支持检查约束。

MySQL支持的这些约束的作用如下：

- 主键约束的作用唯一标识一条记录，不能重复也不能为空，一张长表数据库表只能有一个主键，一般我们会针对 id 字段设置为主键。
- 外键约束的作用是确保表与表之间引用的完整性。
- 唯一性约束的作用是保证字段在表中的数值是唯一的，如果插入人相同字段值的记录，就会报唯一性约束的错误。
- 非空约束的作用是保证字段不能为 NULL。
- 默认约束的作用是给字段设置默认值，如果插入数据的时候，这个字段没有取值的话，就会用默认值。

#### 7、delete、drop、truncate 有什么区别？

##### 回答：

delete 是删除表中的数据，我们可以选择删除部分数据或者全部都数据，delete 删除的数据是可以回滚的；delete 操作并不是真的把数据删除掉了，而是给数据打上删除标记，目的的是为了空间复用，所以 delete 删除表数据，磁盘文件的大小是不会缩减的。
drop 是删除表结构和表中所有的数据，truncate 是只删除表中所有的记录，表结构并不会被删除，drop 和 truncate 删除的数据都是不可以回滚的，并且删除表会立刻料放磁盘空间。
从删除表的性能来看，drop > truncate > delete。

#### 8、联合查询中 union 和 unionall 的区别是什么？

##### 回答：

UNION：在合并结果集后会自动剔除重复的行。
UNION ALL：则会保留所有的重复行，不会进行去重操作。

#### 9、数据库三大范式是什么？追问1：范式设计是为了解决什么问题？追问2：范式设计有什么缺点？

##### 回答：

- 一范式要求所有属性都是不可分的基本数据项；
- 二范式目的是解决部分依赖；
- 三范式目的是解决传递依赖。

在实际的工程实践上没有必要严格遵循三范式要求，比如说可以通过字段冗余的设计，避免联表查询。

##### 追问1回答：

数据库的范式是为了解决数据冗余、数据不一致性、数据更新异常和插入异常等问题。

- 数据冗余：数据冗余是指数据库中存储了大量重复的数据，这不仅良费了存储空间，而且可能导致数据不一致的问题。范式通过规定数据的结构和组织方式，使得每一份数据只需要被存储一次，从而避免了数据冗余。

- 数据更新异常：更新异常是指当我们尝试更新一份数据时，可能需要在多个地方进行修改，而如果某一处修改被遗漏，就会导致数据不一致的问题。范式通过规定数据的的组织和关联方式，使得每一份数据只需要被修改一次，从而避免了更新异常。

- 插入异常：插入异常是指当我们尝试插入一份新的数据时，可能因为数据的组织和关联方式的问题，而无法进行插入。范式通过规定数据的组织和关联方式，使得任何合法的新数据都可以被顺利插入，从而避免了插入异常。

- 保证数据的一致性和完整性：范式化的设计通过消除数据冗余和依赖关系,使得数据的一致性和完整性得到保证。当数据只存在于一个位置时，更新和修改数据更加简单和可靠。通过实施数据库范式，开发人员能够确保数据库架构更具可维护性和可扩展性，尤其在处理大型数据居集时，范式化能够确保数据的一致性，并使数据库操作更高效。

  ##### 追问2回答：

  范式化将数据分解为多个表，那么查询数据的时候，就需要要进行更多的表连接操作，在应用中，进行表关联的成本是很高，也不适合分库分表的场景，所以有时候实际应用，设计表的的时候会反范式的，比如说可以通过字段冗余的设计，避免联表查询。

#### 10、count(*) 性能比 count(1) 好吗？

##### 回答：

不是的。

MySQL 会将星号参数转化为参数 0 来处理，所以 count(*) 和 count(1) 性能是一样的。

### 存储引擎

#### 11、说一说执行一条查询 SQL 语句的全过程

##### 回答：

MySQL 执行一条查询 SQL 语句的时候，会经过连接器、查询缓存、解析器、优化器、执行器、存储引擎这些模块。

- 首先 MySQL 的连接器会负责建立连接、校验用户身份、接收客户端的 SQL 语句；
- 第二步 MySQL 会在查询缓存中查找数据，如果命中直接返回数据线合客户端，否则就需要继续往下查询，不过查询缓存功能在 MySQL8.0 版本被删除了，原因是只要对这张表进行了写操作，这张表的查询缓存就会失效，所以在实际场景中，查询缓存的命中率其实不高；
- 第三步 MySQL 的解析器会对 SQL 语句进行词法分析和语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；
- 第四步 MySQL 的优化器会基于查询成本的考虑，会判断每个索引的执行成本，从中选择查询成本最小的执行计划；
- 第五步 MySQL 的执行器会根据执行计划来执行查询语句，从存储引擎读取记录，返回给客户端。

#### 12、MySQL 存储引擎有哪些？

##### 回答：

MySQL 常见的存储引擎有 InnoDB、MyISAM、Memory。

- 我比较熟悉的是 InnoDB 引擎，它是 MySQL 默认的存储引擎，支持事务和行级锁，具有事务提交、回滚和崩溃恢复功能。
- MyISAM 引擎我没有用过，但是我在学习的时候有了解过，它是不不支持事务和行级锁的，而且由于只支持表锁，锁的粒度比较大，更新性能比较差，我认为它比较适合读多写少的场景。
- Memory 引擎我了解不多，大概知道它是将数据存储在内存中，所以数据的读写还是比较快的，但是数据不具备持久性，我觉得适用于临时存储数据的场景。

#### 13、MyISAM 和 InnoDB 存储引擎有什么区别？

##### 回答：

InnoDB 引擎和 MyISAM 引擎在数据存储上有很大区别，InnoDB引擎数据存储的方式采用的是索引组织表，在索引组织表中，数据即索引，索引即数据，因此表数据和索引数据都存储在同一个文件中。MyISAM引擎数据存储的方式采用的是堆表，在堆表的组织结构中，数据和索引分开存储，因此表数据和索引数据会分别放在两个不同的文件中存储，索引组织表有两个优势：

- 在索引组织表将索引和数据保存在同一个 B+ 树中，相比非聚簇亲引每次查询都需要回表，因此从聚簇索引中获取数据比非聚簇索引更快，查询数据会更快
- 在索引组织表中，如果记录发生了修改，则其他索引无须进行维护，除非记录的主键发生了修改，而当堆表的数据发生改变目位置发生了变更，那么所有索引中的地址都要更新，这非常影响性能。

另外，InnoDB 引擎支持行级锁和事务，而 MyISAM 引擎都不支持，只支持表锁。

#### 14、MySQL 为什么选择 InnoDB 作为默认引擎？

##### 回答：

InnoDB 引擎在事务支持、并发性能、崩溃恢复等方面具有优势，因此被 MySQL 选择为默认的存储引擎。

- 事务支持：InnoDB 引擎提供了对事务的支持，可以进行 ACID （原子性、一致性、隔离性、持久性）属性的操作。MyISAM存储引擎是不支持事务的。
- 并发性能：InnoDB 引擎采用了行级锁定的机制，可以提供更好的发性能，MyISAM 存储引擎只支持表锁，锁的粒度比较大。
- 崩溃恢复：InnoD 引擎通过 redolog 日志实现了崩溃恢复可以在数据库发生异常情况（如断电）时，通过日志文件进行恢复，保证数据的持久性和一致性。MyISAM 是不支持崩溃恢复的。

#### 15、用 count(*) 哪个存储引擎会更快？

##### 回答：

如果查询语句没有 where 查询条件的话，用 MyISAM 引擎会比较快，因为MyISAM 引擎的每张表会用一个变量存储表的总记录个数，执行 count 函数的时候，直接读这个变量就行了，而 InnoDB 引擎执行 count 函数的时候，需要通过遍历的方式来统计记录个数。

如果查询语句有 where 查询条件的话，MyISAM 和 InnoDB 引擎执行 count 函数的时候，性能都差不多，都需要根据查询条件一行行的进行统计。

#### 16、NULL 值是如何存储的？

##### 回答：

MySQL 行格式中会用「NULL值列表」来标记值为 NULL 的列，每个列对应一个二进制位，如果列的值为 NULL，就会标记二进制位为1，否则为0，所以 NULL 值并不会存储在行格式中的真实数据部分。

NULL 值列表最少会占用1字节空间，当表中所有列都定义成 NOT NULL，行格式中就不会有 NULL 值列表，这样可以至少节省1字节的空间。

#### 17、char 和 varchar 有什么区别？追问:哪个性能更好？

##### 回答：

- char 是固定长度的字符串类型，它在数据库中占用固定的存储空间，无论实际存储的数据长度是多少，都会占用定义时指定的固定长度，如果实际存储的字符串长度小于定义的长度，系统会自动用空格填充。比如如果定义一个 char(10) 类型的字段，即使实际数据只使用5字节，会自动地填充5字节的空格，使得存储空间固定占用10字节。
- Varchar 是可变长度的字符串类型。实际存储时只占用实际字符串长度的空间，不会进行空格填充。比如如果定义一个 varchar(10) 类型的字段，并存储了一个长度为5的字符串，那么它只会占用5个字节的存储空间，并且还会额外用1-2字节存储「可变长字符串长度」的空间。

##### 追问回答：

站在 CPU 角度来看，理论上 CHAR 比 VARCHAR 更快，因为 CHAR 是固定长度的，而 VARCHAR 需要增加一个长度标识，处理时需要多一次运算。

但性能是综合各种因素后的最终结果，当 InnoDB buffer pool 小于表大小时，“磁盘读写”成为了性能的关键因素，而 VARCHAR 更短，因此性能反而比 CHAR 高。但是当 InnoDB buffer pool 足够大时，CHAR 和 VARCHAR 性能没有太大的差别了。

#### 18、假如说一个字段是 varchar(10)，但它其实只有6个字节，那他在内存中古的存储空间是多少？在文件中占的存储空间是多少？

##### 回答：

内存会占用10字节，文件存储空间会占用6字节，并且还会额外用1-2字节存储「可变长字符串长度」的空间。

#### 19、如果硬件内存特别大，MySQL 缓存能否替代 redis？

##### 分析：

这个是一个字节的面试题，这里的 MySQL 缓存代表用于缓存数据页的 buffer pool，所以问题的意思是，假设 buffer pool 无限大，能在内存装下所有数据，是否可以替代 redis？问题的回答思路，要去想 redis 缓存哪些优点是 MySQL 没有的？

##### 回答：

我觉得还是不能替代。

- MySQL 所有模块，比如 buffer pool、日志技术、事务并发模快，都是面向磁盘页而设计的，因此其首要目标不是减少内存访问的代价，而是减少 I/0 的代价，所以内存访问代价却并不是最优的选择，而Redis是面向内存而设计的数据库。
- MySQL 在内存查询一个数据页的时候，都需要先查页表，也就是需要走 B+ 树的搜索过程，时间复杂度是 O(logdN)，而 Redis 提供了很多种的数据类型，比如用 Hash 数据对象的时候，可以在 O(1) 时间复杂度查到数据。
- MySQL 在更新数据的时候，MySQL 为了保证事务的隔离性，是需要加锁的，而 Redis 更新操作都是不需要加锁的，还有 MySQL 为了保证事务的持久性，还需要刷盘 redolog 日志和 binlog 日志，Redis 可以选择不持久化数据。

因此，即使 buffer pool 无限大，MySQL缓存的性能还是没有 Redis 好的。

### 索引结构（重要）

#### 20、MySQL 有哪些索引类型？

##### 分析：

B+ 树索引、哈希索引、全文索引的区别:

- B+ 树索引：B+ 树索引是一种平衡树数据结构，它将数据按照索引键值有序地存储在树的叶子节点上，非叶子节点只存储索引键值和指向下一层节点的指针，适合于范围查找、排序查询、等值查询的情况，并且性能稳定；因为B+ 树保存千万级别的数据，树的高度依然维持在3-4层左右，也就是从千万级数据查询一条数据只需要3-4次的磁盘 I/O 操作就能查询到目标数据。
- 哈希索引：哈希索引是通过哈希算法将键值（key-value）映射到哈希表中,再根据哈希表进行索引操作。哈希索引适合于等值查询，例如根据主键查询某条记录，查询时间复杂杂度为 O(1)，效率非常高，但不支持排序、范围查询及模糊查询等。
- 全文索引：全文索引是一种用于全文搜索的索引技术，可以对文本内容进行索引，支持关键词的模糊匹配和搜索。一般用于查找文本中的关键字，而不是直接比较是否相等，主要是用来解决 WHERE name LIKE "%aaaa%" 等针对文本的模糊查询效率低的问题。

##### 回答：

我了解到 MySQL 支持 B+ 树索引、哈希索引、全文索引这三种素引类型。我比较常用的是 B+ 树索引，因为它是 InnodB 引擎默认使用的索引类型，支持排序、分组、范围查询、模糊查询等功能。

#### 21、InnodB 引擎的索引数据结构是什么？

##### 回答：

我了解到 InnodB 引擎是采用了 B+ 树作为索引的数据结构。它的一些特性:

1. 数据组织形式：InnodB 存储引擎的主键索引 B+ 树的非叶子节点只存放索引键值和指向子节点的指针，不存储实际的数据，这里对应到 MySQL 中就是索引，叶子节点存储素引健值和行数据，所以 InnodB 存储引擎的主键索引属于聚簇索引。
2. 叶子节点链表：所有叶子节点通过指针相连，形成一个双向链表，支持快速的顺序访问和范围查询。
3. 平衡树结构：所有叶子节点在同一层上，树的高度平衡，保证任何数据记录的查找、插入、删除和更新操作的路径长度相同，稳定性好。

#### 22、B+ 树的特性是什么？

##### 回答：

B+ 树是一个多叉树，一个父节点，可以有多个子节点，主要的特性有三个:

- B+ 树的中间节点不会存储数据，而只有叶子节点才会存储，中间节点只用于存储到叶子节点的路由信息（即索引），而且每个节点里的数据都是根据素引的值来顺序存放的。
- B+ 树的所有的叶子节点之间会通过双向指针串联在一起，构成一个双向链表，可以方便扫表和范围查询。
- B+ 查询性能稳定，因为所有叶子节点都在同一层，确保了所有数据项的检索都具有相同的 I/O 延迟，而且 B+ 树保存千万级别的数据，树的高度依然维持在3~4层左右，也就是从千万级数据查询一条数据只需要3~4次的磁盘 I/O 操作就能查询到目标数据。

#### 23、B+ 和 B 树有什么区别？

##### 回答：

B+ 和 B 树都是多叉平衡树，每个节点包含多个键和多条链，主要的区别有这些：

- B 树所有节点都会存储索引+数据，而B+树只有叶子节点才会存储数据，中间节点则只有索引，因此存储相同数据量的情况下，B+ 树可以比B树更矮胖，查询叶子节点的磁盘 I/O 次数会更少。
- B+ 树叶子节点之间会通过双向指针串联在一起，构成一个双向链表，这种设计对范围查找非常有帮助，而 B 树没有将所有叶子节点用链表串联起来的结构，只能通过中序遍历来完成范围查询，这会比 B+ 树范围查询涉及更多个节点的磁盘 I/O 操作，因此范围查询效率不如 B+ 树。
- B 树的优势是当你要查找的值恰好处在一个非叶子节点时，由于干该节点也包含数据，查找到该节点就会成功并结束查询，最快可以在 O(1) 的时间代价内就查到，而 B+ 树由于数据只在叶子节点，所以每次查询都需要从根节点搜索到叶子节点，从平均时间代价来看，会比 B+ 树稍快一些，但是 B+ 树的查询会更稳定，因为每次查询都是相同的 I/O 延迟。

#### 24、MySQL 为什么使用 B+ 树？

##### 回答：

- B+ 树是多叉树，而平衡二叉树、红黑树是二叉树，在同等数据量下，平衡二叉树、红黑树高度更高，磁盘IO次数更多，性能更差，而且它们会频繁执行再平衡过程，来保证树形结构平衡。
- 跳表和 B+ 树相比，跳表在极端情况下会退化为链表，平衡性差，而数据库查询需要一个可预期的查询时间，并且跳表需要更多的内存。
- B 树和 B+ 树相比，B树的数据存储在全部节点中，对范围查询不友好。非叶子节点存储了数据，导致内存中难以放下全部非叶子节点。如果内存放不下非叶子节点，那么就意味着查询非叶子节点的时候都需要磁盘IO。

#### 25、为什么索引用 B+ 树？而不用红黑树？

##### 回答：

我觉得主要原因是随着数据量的增多，红黑树的树高会比 B+ 树的树高，这样查询数据的时候会面临更多的磁盘 I/O，查询性能没那么好。因为红黑树本质上是二叉树，而B+权对是多叉树，存储相同数量量的情况下，红黑树的树高会比 B+ 树的树高，由于 InnodB 引擎的数据都是存储在磁盘上的，如果树的高度越高，意味着磁盘 I/O 就越多，这样就会影响查询性能。
另外，B+ 树叶子节点是通过双向链表组织的，可以很好的实现范围查询，红黑树要实现范围查询需要通过中序遍历，这会比 B+ 树范围查询涉及更多个节点的磁盘 I/O 操作，因此范围查询效率不如 B+ 树。
所以，B+ 树相比红黑树有两个优势，第一个优势是 B+ 树随着数据的增多的时候树的高度会比红黑树低，第二优势是 B+ 树范围查询很方便，直接通过叶子节点的链表就能完完成了，因此 InnodB 存储引擎选择了 B+ 树作为索引。

#### 26、为什么索引用 B+ 树？而不用 B 树？

##### 回答：

我觉得主要有三个原因：

- **B+ 树的磁盘读写代价更低：**B+ 树只有叶子节点才会存放索引和数据，非节点只存放索引，而 B 树所有节点都会存放索引和数据，因此存储相同数据量的情况下，B+ 树可以比 B 树更矮胖，查询叶子节点的磁盘 I/O 次数会更少
- **B+ 树便于范围查询：**MySQL 是需要经常使用范围查询的，B+ 树所有叶子节点间会用链表进行连接，这种设计对范围查找非常有帮助，而 B 树没有将所有叶子节点用链表串联起来的结构，只能通过中序遍历来完成范围查询，这会比 B+ 树范围查询涉及更多个节点的磁盘 I/O 操作，因此范围查询效率不如 B+ 树
- **B+ 树增删查改效率更加稳定：**B+ 树有大量的冗余节点，这些冗余数据可以让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树对的变化。另外，B+ 树把所有的用户记录都放到了叶子节点这一层,因此查询、插入、删除数据都需要走到最后一层，这不同于B树可能在任意一层找到数据，所以 B+ 树更为稳定。

所以，InnoDB 引擎的索引选择了 B+ 树。

#### 27、为什么索引用 B+ 树？而不用哈希表？

##### 分析;

1. 哈希表的数据是散列分布的，不具备有序性，无法进行范围查和排序
2. 哈希表存在哈希冲突的问题，哈希冲突严重，也会降低查询效率

##### 回答:

MySQL 会有很多范围查询和排序的场景，虽然哈希表的搜索时间复杂度是 O(1)，但是由于哈希表的数据都是通过哈希函数计算后散列分布的，所以哈希表索引不支持范围查询和排序操作，不支持联合索引最左匹配原则，如果重复键值比较多，还容易造成哈希碰撞导致效率进一步降低。而 B+ 树可以满足这些应用场景，因此选择了用 B+ 树索引。

#### 28、B+ 树有什么优点和缺点？

##### 回答：

**B+ 树有一个最大的好处是方便范围查询**，B+ 树的叶子节点之间有链表，直接通过叶子节点链表就能方便的完成范围查询的工作，而 B 树必须用中序遍历的方法来实现范围查询间，这会比 B+ 树范围查询涉及更多个节点的磁盘 I/O 操作，因此范围查询效率不如 B+ 树。
**B+树最大的性能问题是会产生大量的随机IO**，随着新数据的插入，叶子节点会慢慢分裂，逻辑上连续的叶子节点在物理上往往不连续,甚至分离的很远，但做范围查询时，会产生大量读随机 IO 。对于大量的随机写也一样，举一个插入 key 跨度很大的例子，如 7->1000->3->2000.... 新插入的数据存储在磁盘上相隔很远，会产生大量的随机写 IO。

#### 29、聚簇索引和非聚簇索引有什么区别？

##### 回答：

聚簇索引和非聚簇索引（二级索引）最主要的区别是 B+ 树叶子书点存放的内容不同：

- 聚簇索引的 B+ 树叶子节点存放的是主键值+完整的记录
- 非聚簇索引的 B+ 树叶子节点存放的是索引值+主键值

如果查询语句的查询条件用了二级索引，但是查询的数据不是主键值，也不是二级索引值，这时在二级索引找到主键值后，就需要回表才能查找到数据，需要扫描两次 B+ 树。如果查询的列是主键值和二级索引值时，因为只在二级索引就能查询到，这时候就会用到覆盖索引，不需要回表，只需要扫描一次 B+ 树。

#### 30、什么是覆盖索引？

##### 回答：

当查询的数据是能在二级索引的叶子节点里查询到的话，这l时就不用再回主键索引查了，那就不需要回到主键索引去查行记录了，这种不需要回表的过程，就叫覆盖索引，这种查询方式效率会比较高，只需要查二级索引这一棵 B+ 树。

#### 31、什么情况下会回表？

##### 回答：

在使用二级索引进行查询的时候，如果查询的列，不能在二级索引中全部查询到，那么就会发生回表的过程，先通过二级索引的值查到聚簇索引值（即主键id），再通过聚簇索引的的值定位行记录数据，需要扫描两次索引 B+ 树，它的性能较扫一遍索引树更低。

#### 32、insert 操作对 B+ 树结构的改变是怎么样的？

##### 回答：

B+ 树的数据都是有序的，所以：

- 如果我们使用主键是顺序递增，那么每次插入的新数据就会顺序插入到叶子节点最右边的节点里，如果该页面满了，就会自动开辟一个新页面，将新数据插入到新页面。因为每次插入一条新记录，都是追加操作，不需要重新移动数据，因此这种插入数据的方法效率非常高。
- 如果我们使用主键不是顺序递增，由于每次插入主键的索引值都是是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这时候为了保证 B+ 树的有序性，要移动其它数据来满足新数据的插入。如果该页面满了，就发生页分裂，这时候要从一个页面复制数据到到另外一个页面，目的是保证后一个数据页中的所有行主键值比前一个数据页中主键值大，页分裂可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。

所以，我们在设计主键的时候，最好采用自增的方式，或者顺序递增主键值。

#### 33、假如一张表有两千万的数据，B+ 树的高度是多少？怎么算的？



2025年3月27日

------



### 索引应用（重要）

#### 34、MySQL 有哪些索引？

##### 分析：

主键索引、唯一索引、普通索引、前缀索引、联合索引。

- 主键索引：主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。
- 唯一索引：唯一索引建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。
- 普通索引：普通索引就是建立在普通字段上的索引，既不要求字段设为主键，也不要求字段为 UNIQUE。
- 前缀索引：前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、varchar、binary、varbinary 的列上。使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。
- 联合索引：通过将多个字段组合成一个索引，该索引就被称为联合索引。

##### 回答：

我了解到 MySQL 有主键索引、唯一索引、普通索引、前缀索引、前缀索引、联合索引这几种索引。InnoDB 引擎会要求每一张数据库表都必须要有一个主键索引，比如表里的 id 字段就是主键索引。

然后针对查询比较频繁的字段，我们可以对这个字段建立普通索引，如果是多个字段的话，可以考虑建立联合索引，利用索引覆盖的特性提高查询效率。

对于长文本、字符串等类型的字段，比如文章标题、商品名称等，我们可以只对这些字段的前缀部分建立索引，也就是建立前缀索引，这样可以减少索引的存储空间。

#### 35、MySQL 主键是聚簇索引吗？

##### 分析：

聚簇索引就是按照每张表的主键构造一棵 B+ 树，同时叶子节点中存放的是整张表的行记录数据，就好像把数据和索引聚集在了一棵 B+ 树上，所以这种数据组织形式的索引叫聚簇索引。

每张表只能拥有一个聚簇索引，因为数据库表的数据都是存放在聚簇索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚簇索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个。

InnoDB 在创建聚簇索引时，会根据不同的场景选择不同的列作为索引：

- 如果定义了主键，默认会使用主键作为聚簇索引的索引键；
- 如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键；
- 在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id(row_id) 列作为聚簇索引的索引键。

##### 回答：

是的，主键是聚簇索引，我们创建数据库表的时候，通常都会对 id 字段设置为主键索引，InnoDB 在创建聚簇索引时，默认会使用主键作为聚簇索引的索引键。

#### 36、主键为什么不推荐有业务含义？

##### 回答：

我觉得原因两个：

- 第一个业务会有变动的可能性，我们谁也无法预测在项目的整个生命周期中，哪个业务字段会因为项目的业务需求而有重复，或者重用之类的情况出现，等需要变动的时候，去更改主键是成本很高的一件事情，不如设计阶段就规避不用有业务含义的主键。
- 第二个是业务含义的主键可能不是顺序自增的，有可能会发生页分裂问题，从而影响性能。

#### 37、主键是用自增还是 UUID  ？

##### 回答：

用自增 id 比较好，因为 UUID 是随机值，在数据插入的过程中，会导致索引树发生页分裂的问题，会影响性能，而且 UUID 是字符串类型，长度比较长，占用内存比较大，而页的大小是固定的，这样会导致索引树的高度越高，查询的时候会发生的磁盘IO次数也越多，性能也就更低。

但是自增 id 在分库分表环境下就不适用了，因为没办法保证全局唯一，这时候就需要考虑用雪花算法来作为主键了。

#### 38、普通索引和唯一索引有什么区别？哪个更新性能更好？

##### 回答：

普通索引列的值是可以重复的，而唯一索引列的值是必须唯一的，当我们对唯一索引插入了一条重复的值，会因为唯一性约束而报错。

我认为普通索引的更新性能会更好，因为普通索引在更新的I时候，如果更新的数据页不在内存的话，可以直接把更新操作缓存在 change buffer 中，更新操作就结束了；但是，唯一索引因为需要有唯一性约束，如果更新的数据页不在内存的话，需要从磁盘读取对应的数据页到内存，判断到没有冲突，这里会涉及磁盘随机 IO 的访问。

普通索引因为能使用 change buffer 特性，所以普通索引的更新相比于唯一索引，减少了随机磁盘访问，所以更新性能更好。

#### 39、主键怎么设置？追问：假如你不设置会怎么样？

##### 回答：

在创建表的时候，对 id 列设置为 PRIMARYKEY，那么 id 列就是是主键索引了。

##### 追问回答：

如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键，如果这个条件也没有达成的话，InnoDB 将自动生成一个隐式 row id 列作为聚簇索引的索引键。

#### 40、介绍一下什么是外键约束？

##### 回答：

外键就是「从表」中用来引用「主表」中数据的那个公共字段，外键约束确保了数据的引用完整性,也就是「从表」中的外键必须存在于「主表」的主键中，如果发现要删除的主表记录，正在被「从表」中某条记录的外键字段所引用，MySQL 就会提示错误，从而保证了2个表中数据的一到致性。

#### 41、外键有什么优劣势？

##### 回答：

外键能够保证数据的一致性和完整性，通过设置外键，数据库就会判断数据的完整性，不需要在应用代码里实现。

有了外键之后，每次增删改都需要额外检查外键约束，会占用数据库的计算资源，影响增删改的性能，而且还需要额外获取锁，在高并发场景下很容易发生死锁的问题；另外，外键也不适合分库分表的场景，外键难以跨越不同数据库来建立关系。

因此，基于性能开销、锁竞争、分库分表的考虑，一般项目中，很少用外键约束，都是在应用层面完成检查数据一致性的逻辑，就像大厂会使用 RC（读已提交隔离级别）来替代 RR（可重复读隔离级别）一样，会尽可能的降低锁的发生，一方面提升性能，一方面降低死锁概率。

#### 42、为什么要建索引？

##### 分析：

考察索引的优点。建索引的三个优点：

- 索引大大减少了 MySQL 需要扫描的数据量；
- 索引可以帮助 MySQL 避免外部排序和使用临时表；
- 索引可以将随机 I/O 变为顺序I/O。

##### 回答：

如果没有建立索引，我们查询数据的话，搜索时间复杂度是 O(n)，这样的查询效率还是比较低的，为了提高查询效率，我们可以建立索引。
建立了索引后数据都会按照顺序存储，这时候我们可以利用类似二分查找的方式快速查找数据，B+ 树索引是多叉树，搜索时间复杂度是 O(logdN)，这样就提高了查询速度，除此之外还可以避免外部排序和使用临时表等问题，以及将随机 I/O 变为顺序I/O。

#### 43、我们一般选择什么样的字段来建立索引？

##### 回答：

可以对频繁用于 WHERE 查询条件的字段建立索引，这样能够提高整张表的查询速度，如果查询条件不是一个字段，可以考虑建立联合索引。还有对于经常用于排序、分组的字段建立索引，这样在查询的时候就不需要再去做一次排序了，因为建立索引之后在 B+ 树中的数据都是排序好的。

不过，对于一些区分度不高的字段，比如性别字段，只有男女，不建议建立索引，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据，在这种情况下，MySQL 的优化器发现某个值在表中出现的比例很高的时候，它一般会忽略索引，进行全表扫描，这时候候建立的索引就没有起到作用，反而还占用了存储空间。

#### 44、索引越多越好吗？

##### 回答：

不是的，索引虽然能提高查询效率，但是多建立一个索引，就意味着新生成一个 B+ 树索引，是需要占用存储空间的，特别是在表数据量非常大的时候，索引占用的空间越大。

还有，索引越多数据库的写入性能会下降，因为每次对表进行增删改操作的时候，都需要去维护各个 B+ 树索引的有序性。

#### 45、什么时候不用索引更好？

##### 回答：

建立了索引，虽然能提升查询效率，但是它带来了两个代价，第一个是空间代价，因为需要多构建一颗 B+ 树，会占用磁盘空间。第二个更新时间代价，每次增删改索引，都需要动态维护 B+ 树，以满足 B+ 树的有序性。

所以，我认识到如果一张表经常被增删改的话，也就是写多读少的场景下，不建立索引会更好，因为这时候维护索引的开销可能会超过索引带来的性能提升。

还有一点，如果表中某个列的值高度重复，那么建了索引也没有用，优化器会选择全表扫描，这样建立的索引会占用存储空间，也会影响增删改的效率，选择不用索引会更好。

#### 46、字段为什么要定义为NOT NULL？

##### 回答：

- 如果查询中包含可为 NULL 的列，对 MySQL 的优化器来说更难优化，因为可为 NULL 的列使得索引、索引统计和值比较都更复杂。
- 如果某列存在 NULL 的情况，可能导致 count() 等函数执行不准确，因为 count 不会统计值为 NULL 列。
- NULL 值是一个没意义的值，但是它会占用物理空间，因为 InnoDB 存储记录的时候，如果表中存在允许为 NULL 的字段，那么行格式中至少会用1字节空间存储 NULL 值列表。

#### 47、索引怎么优化？

##### 回答：

我用过这几种优化的方式：

- 对于只需要查询几个字段数据的 SQL 来说，我们可以对这些字段建立联合索引，这样查询方式就变成了覆盖索引，避免了回表，减少了大量的 I/O 操作。
- 我们的主键索引最好是递增的值，因为我们索引是按顺序存储数居的，如果主键的值是随机的值，可能会引发页分裂的现象，页分裂会导致大量的内存碎片，这样索引结构不紧凑了，就会影响查询效率。
- 我们要避免写出发生索引失效的 SQL 的语句，比如不要对索引进行计算、函数、类型转换操作，联合索引要能正确使用需要遵循最左匹配原则等等。
- 对于一些大字符串的索引，我们可以考虑用前缀索引只对索引列的前缀部分建立索引，节省索引的存储空间，提高查询性能。

#### 48、建立了索引，查询的时候一定会用到索引吗？

##### 回答：

不是的。

我了解到即使查询使用到了索引，也是可能不走索引的，比如：

- 当我们查询语句对索引字段进行左模糊匹配、表达式计算、函数、隐式类型转换操作，这时候查询语句就无法走索引了，查询方式就变成了全表扫描的方式。还有我们使用联合索引进行查询的时候，如果没有遵循最左匹配原则，也是会发生索引失效的。
- 优化器是基于成本考虑来选择查询的方式，在使用二级索引进行查询的时候，优化器会计算回表的成本和全表扫描的成本，如果回表的代价太高，优化器会选择不走索引，而是走全表扫描。

#### 49、如果我定义了一个 varchar 类型的日期字段，并且有一个数据是 ‘202330922’，如果这个日期字段上有索引，那如果我查询的 where 条件是 where time=20230922 不加单引号，还会命中索引吗？为什么？

##### 回答：

不会命中索引。

因为 MySQL 在遇到字符串和数字比较的时候，会发生隐式类型转换，会将字符串的对象转为数字，这个转换的过程实际上会涉及到函数。你说的这个查询，日期字段是字符串，那么发生隐式类型转换的时候，就会作用在日期这个索引字段上，对索引进行函数计算的话，是会发生索引失效的。

#### 50、MySQL 最新版本解决了索引失效的哪些情况了吗？

##### 回答：

我了解到 MySQL8.0 可以给字段增加函数索引，这个新特性可以解决对索引使用函数的时候，索引失效的问题。

还有一个新特性是索引跳跃式扫描，5.7版本之前，使用联合索引的时候，如果不满足最左匹配原则，就会发生索引失效，而8.0出了索引跳跃式扫描特性之后，即使没有遵循最左匹配原则，部分场景下，依然可以使用联合索引。

#### 51、什么是最左匹配原则？

##### 回答：

假设有一个 (a,b,c) 联合索引，它的存储顺序是先按 a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。由于这个的特性，在使用联合索引时，存在最左匹配原则，具体的规则：

- MySQL 会从联合索引从最左边的索引列开始匹配查询条件，然后依次从左到右的顺序匹配，如果查询条件没有使用到某个列，那么该列右边的所有列都无法使用走索引。
- 当查询条件中使用了某个列，但是该列的值包含范围查询，范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。

所以，我们在使用联合索引的时候，要遵守最左匹配原则，否则可能会出现部分索引字段走不了索引。

#### 52、建立联合索引有什么需要注意的？

##### 回答：

最好把区分度比较大的字段放在联合索引最左侧，有助于提高索引的过滤效果，比如 UUID 这类字段就比较适合排在联合索引列的靠前的位置。

如果区分度很低的字段放在了联合索引最左侧，有可能会导致查询优化器会选择全表扫描，而不走索引了。

#### 53、了解索引下推吗？什么情况下会下推到引擎去处理？

##### 回答：

索引下推能够减少二级索引在查询时的回表操作，提高查询的效率，因为它将 Server 层部分负责的事情，交给存储引擎层去处理了。
举个例子，联合索引 (a,b,c)，查询条件为 a=? and c=? 的时候，由于联合索引的最左匹配原则，c是无法走索引的，在没有索引下推机制之前，查询语句走二级索引的时候，需要回表读取 c 的值，然后在 server 层进行过滤，有了索引下推机制后，即使 c 无法走索引，但是由于 c 在二级及索引里，那么将过滤 c 的工作从 server 层下推到存储引擎层，这样直接在二级索引里过滤满足 c 条件的记录，减少了回表的次数。

#### 54、联合索引(a,b,c)，下面的查询语句会不会走索引？如果走具体是哪些字段能走？

1. select * from T where a=1 and b=2 and c=3;
2. select * from T where a=1 and b>2 and c=3;
3. select * from T where c=1 and a=2 and b=3;
4. select * from T where a=2 and c=3;
5. select * from T where b=2 and c=3;
6. select (a,b) from T where a=1 and b>2

##### 回答：

1. 遵循最左匹配原则，所以 abc 三个字段都可以走索引，查询方式是在联合索引找到主键值后，会回主键索引找完整的数据行。
2. 根据最左匹配原则，范围查询后面的字段无法使用索引，所以 ab 可以走索引，c 无法走索引，不过 c 可以进行索引下推。
3. abc 都能走索引，因为 where 查询条件字段的顺序并不会影响，MySQL 优化器会帮我们调整字段的查询顺序，所以也是符合最左匹配原则的。
4. a 能走索引，根据最左匹配原则，c 无法走索引，但是 c 可以被索引下推
5. 根据最左匹配原则，bc 都无法走索引。
6. a 和 b 都能走索引，查询方式是覆盖查询，不需要回表。

#### 55、where a>1 and b=2 and c<3 怎么建立索引？

##### 分析：

这题属于上一题的反向思维，根据查询条件，创建联合索引，来提高这条语句的查询效率，所以就要创建一个能让更多字段能走索引的联合索引。
假设：
创建 (abc)、(acb)、(ab)、(ac) 联合索引，只有 a 能索引
创建 (cab)、(cba)、(ca)、(cb) 联合索引，只有 c 能索引
创建 (ba) 联合索引，b 和 a 都能走索引
创建 (bc) 联合索引，b 和 c 都能走索引
创建 (bac) 联合索引，b 和 a 都能走索引，但比 (ba) 联合索引多了一个好处，c 字段能索引下推，会减少回表的次数；
创建 (bca) 联合索引，b 和 c 都能走索引，但比 (bc) 联合索引多了一个好处，a 字段能索引下推，会减少回表的次数。

##### 回答：

我会创建 (bac) 联合索引或者 (bca) 联合索引，因为这两种联合素引都可以有2个字段走索引。

- 创建 (bac) 联合索引，b 和 a 都能走索引，c 字段虽然无法走索引，但是可以进行索引下推，这样会减少回表的次数；
- 创建 (bca) 联合索引，b 和 c 都能走索引，a 字段虽然无法走索引，但是可以进行索引下推，这样会减少回表的次数。

#### 56、where a=？and b=？order by c 怎么建立索引？

##### 分析;

这里有 order by 排序，我们尽量要用索引来避免额外排序的操作，可以考虑建立 (a,b,c) 联合索引，因为 c 有序的前提是建立在 a=? And b=? 的场景下，刚好符合这个查询条件，这样 c 就不需要额外排序了，天然利用了索引的有序性。

##### 回答：

可以建立 (a,b,c) 联合索引，这样 c 排序的时候，就能利用索引的有序性，避免 using filesort 了。

#### 57where a>100 and b=100 and c=123 order by d 怎么建立联合索引？

##### 回答：

我觉得建立 bcda 顺序的联合索引比较好，这时候 b 和 c 字段没都能走索引，而且 d 能利用索引有序性，避免 filesort，最后的 a 字段虽然无法走索引，但是可以利用索引下推，减少回表的次数。

#### 58、select b from table where a=10 and c>20 怎么创建索引？

##### 分析;

优先考虑能让 where 查询中的字段能走索引,所以可以考虑 (a,c) 联合索引,这样查询的时候，a 和 c 都能走联合索引，然后再考虑 select 的列是否能索引覆盖，很明显这个查询场景，只需要查询 b 列，那么我们可以考虑创建 (a,c,b) 联合索引，这时候查询的时候，a 和 c 既能走索引，也能索引覆盖，避免了回表。

##### 回答：

可以考虑创建 (a,C,b) 顺序的联合索引，这时候查询的时候，a 和 c 既能都走索引，也能利用索引覆盖的特性，避免了回表。

#### 59、select id, name from XX where age > 10 and name like 'xx%'，有联合索引 (name,age)，说一下查询过程

##### 分析;

有三点需要说出来：

- 能不能走索引？哪些字段能走索引？能走索引，name 能走索引，age不能走索引。
- 哪个字段能索引下推？age 字段能索引下推
- 查询需不需要回表？不需要回表，索引覆盖查询

##### 回答：

联合索引的顺序是先 name，再 age，结构上是先根据 name 排序，nam 相等的情况下再根据 age 排序。所以优化器需要先匹配 name，name 这时候是右模糊查询，并不会发生索引失效，所以这条 sql 是能走联合索引的，具体的话，只有 name 能走索引，这是因为由于 name 右模糊查询后，age 字段的值并不是有序的，因此 age 无法走索引，但是 age 可以进行索引下推。

最后查询的字段是 id 和 name，这两个字段都能在联合索引上查找到，所以不需要回表，是索引覆盖查询。

#### 60、where id NOT IN (?,?,?) 会走索引吗？

##### 回答：

要看查询成别，如果走某个索引花费的随机 I/O 比从聚簇索引顾序查（顺序 I/O）的成本都还要高，那还不如直接去全表扫描。

举例：num 字段（非唯一二级索引）只包含3个值，1、2、3，3只有几行，而1、2各有100w行，如果查询条件是 NOT IN(1,2) 会走索引，如果查询条件是NOT IN(3) 不会走索引。

#### 61、如果查询条件中包含索引列和非索引列，MySQL 的具体查询流程是什么样的？

##### 回答：

查询过程先按索引去二级索引 B+ 树查，然后拿到主键 id，回表到主键索引 B+ 树再过滤非索引列，查询过程会查2个 B+树，涉及回表的过程。

2025年3月28日

------

### 事务（重要）

#### 62、MySQL 事务有什么特性？

#### 63、事务的隔离性如何保证？

#### 64、事务的持久性如何保证？

#### 65、事务的原子性如何保证？

#### 66、MySQL 事务和 Redis 事务有什么区别？

#### 67、MySQL 事务隔离级别有哪些？分别解决哪些问题？

#### 68、串行化隔离级别是通过什么实现的？

#### 69、脏读和幻读有什么区别？

#### 70、MySQL 默认的隔离级别是什么？怎么实现的？

#### 71、介绍一下 MVCC

#### 72、MVCC 的如何判断行记录对某一个事务是否可见？

#### 73、读已提交和可重复读隔离级别实现 MVCC 的区别？

#### 74、为什么互联网公司用读已提交隔离级别？

#### 75、可重复读隔离级别是如何解决不可重复读的？

#### 76、可重复读隔离级别是怎么解决幻读的？

#### 77、可重复读隔离级别解决了什么问题？有没有完全解决幻读？

#### 78、可重复读隔离级别为什么不能完全避免幻读？什么情况下出现幻读？

#### 79、可重复读隔离级别，MVCC 完全解决了不可重复读问题吗？

#### 80、一个事务里有特别多 SQL 的弊端？

### 锁

#### 81、详细说一下 MySQL 数据库中锁的分类（重要）

#### 82、MySQL 怎么实现乐观锁？（重要）

#### 83、在线上修改表结构,，会发生什么？

#### 84、创建索引的时候会锁表吗？

#### 85、InnoDB 存储引擎中的行级锁有哪些？（重要）

#### 86、间隙锁的工作原理是什么？

#### 87、一条 Update 语句没有带 where 条件，加的是什么锁？

#### 88、带了 where 条件没有命中索引，加的是什么锁？

#### 89、两条更新语句更新同一条记录，加的是什么锁？

#### 90、两条更新语句更新同一条记录的不同字段，加的是什么锁？

#### 91、可重复读场景，下面的场景会发生什么？

#### 92、了解过MySQL死锁问题吗？

#### 93、MySQL怎么排查死锁问题？

#### 94、MySQL怎么避免死锁？



------



### 日志

#### 95、MySQL 三大日志是什么？（重要）

#### 96、redo log 和 binlog 的区别和应用场景？

#### 97、redo log 和 binlog 在恢复数据库有什么区别？

#### 98、为什么崩溃恢复不用 binlog 而用 redo log？

#### 99、binlog 的三种格式是什么？

#### 100、redo log 是怎么实现持久化的？

#### 101、redo log 除了崩溃恢复还有什么其他作用？

#### 102、为什么需要两阶段提交？

#### 103、两阶段提交的过程？

#### 104、Redo log刷盘策略有哪三种？